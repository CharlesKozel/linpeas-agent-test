from unittest import result
from llm_interface import LLMInterface
from ssh_client import SSHClient
from utils.logger import setup_logging


from colorama import Fore, Style

import logging
import sys
from pathlib import Path
from typing import Optional, List, Tuple

import json
import os
import re
import time
from datetime import datetime
from typing import Dict

from utils.peas2json import parse_peas_critical


class InteractivePentestAgent:
    """Interactive LLM-to-SSH penetration testing agent"""

    def __init__(self, target_ip: str, username: str, password: str = None,
                 key_file: str = None, port: int = 22, max_iterations: int = 50):
        self.target_ip = target_ip
        self.username = username
        self.password = password
        self.key_file = key_file
        self.port = port
        self.max_iterations = max_iterations

        # Initialize components
        self.ssh_client = None
        self.llm = LLMInterface()

        # Session tracking
        self.session_id = datetime.now().strftime("%Y%m%d_%H%M%S")
        
        self.command_history = []
        
        self.system_info = {}
        self.current_user = ""
        self.privilege_escalated = False
        self.iteration_count = 0

        # Setup logging
        self.logger = setup_logging(f"interactive_session_{self.session_id}")

    def start_interactive_session(self) -> bool:
        """MAIN STARTING POINT: Run the interactive LLM-to-SSH session"""
        try:
            print(f"{Fore.GREEN}ü§ñ Starting Interactive LLM-to-SSH Penetration Test{Style.RESET_ALL}")
            print(f"Target: {self.target_ip}")
            print(f"Session ID: {self.session_id}")
            print(f"Max Iterations: {self.max_iterations}")

            # Initialize connection
            if not self.initialize_connection():
                return False

            print(f"\n{Fore.GREEN}‚úÖ Connected to {self.target_ip} as {self.current_user}{Style.RESET_ALL}")
            print(f"System: {self.system_info.get('os', 'Unknown')}")
            print(f"Kernel: {self.system_info.get('kernel', 'Unknown')}")

            self.copy_linpeas()

            # Main interaction loop
            while self.iteration_count < self.max_iterations and not self.privilege_escalated:
                print(f"\n{Fore.BLUE}{'='*80}")
                print(f"ITERATION {self.iteration_count + 1}/{self.max_iterations}")
                print(f"{'='*80}{Style.RESET_ALL}")

                # Ask LLM for next command
                command_info = self.ask_llm_for_next_command()

                if not command_info:
                    print(f"{Fore.RED}Failed to get command from LLM, ending session{Style.RESET_ALL}")
                    break

                # Check if LLM wants to continue
                if not command_info.get('continue_session', True):
                    print(f"{Fore.YELLOW}LLM decided to end the session{Style.RESET_ALL}")
                    print(f"Reason: {command_info.get('reasoning', 'No reason provided')}")
                    break

                # Execute command with user approval
                execution_result = self.execute_command_with_approval(command_info)

                # Check if we achieved privilege escalation
                if self.check_privilege_escalation():
                    print(f"\n{Fore.GREEN}üéâ PRIVILEGE ESCALATION ACHIEVED! üéâ{Style.RESET_ALL}")

                if not execution_result:
                    print(f"{Fore.YELLOW}Command skipped or failed{Style.RESET_ALL}")
                    self.iteration_count += 1
                    continue

                if execution_result.get('terminate'):
                    print(f"{Fore.RED}Session terminated by user{Style.RESET_ALL}")
                    break

                self.iteration_count += 1

                # Brief pause between iterations
                time.sleep(1)

            # Session summary
            self.generate_session_summary()

            return True

        except KeyboardInterrupt:
            print(f"\n{Fore.YELLOW}Session interrupted by user{Style.RESET_ALL}")
            return False
        except Exception as e:
            self.logger.error(f"Session error: {e}")
            print(f"{Fore.RED}Session error: {e}{Style.RESET_ALL}")
            return False

    
    def initialize_connection(self) -> bool:
        """Establish SSH connection to target"""
        try:
            self.ssh_client = SSHClient(
                hostname=self.target_ip,
                username=self.username,
                password=self.password,
                key_filename=self.key_file,
                port=self.port
            )

            if self.ssh_client.connect():
                self.logger.info(f"Successfully connected to {self.target_ip}")

                # Get initial system information
                self.system_info = self.ssh_client.get_system_info()
                self.current_user = self.system_info.get('whoami', 'unknown')

                return True
            else:
                self.logger.error(f"Failed to connect to {self.target_ip}")
                return False

        except Exception as e:
            self.logger.error(f"Connection initialization failed: {e}")
            return False
        

    def copy_linpeas(self):
        self.ssh_client.upload_file(f'{os.getcwd()}/linPEAS/linpeas.sh', 'linpeas.sh')
        self.logger.info("Uploaded linpeas.sh")


    def ask_llm_for_next_command(self) -> Optional[Dict]:
        """Ask LLM for the next command to execute"""
        self.logger.info("Requesting next command from LLM...")

        system_prompt = self.make_system_prompt()
        user_prompt = self.make_user_prompt()

        try:
            response = self.llm.prompt_llm(user_prompt, system_prompt)
            

            # Parse JSON response TODO: handle invalid JSON from LLM, ask it to fix
            json_match = re.search(r'\{.*\}', response, re.DOTALL)
            if json_match:
                command_info = json.loads(json_match.group())

                # Validate required fields
                required_fields = ['reasoning', 'command', 'expected_outcome', 'continue_session']
                if all(field in command_info for field in required_fields):
                    return command_info
                else:
                    self.logger.warning("LLM response missing required fields")
                    return None
            else:
                self.logger.warning("Could not parse LLM response as JSON")
                return None

        except Exception as e:
            self.logger.error(f"Error getting LLM command: {e}")
            return None


    def make_system_prompt(self):
        system_prompt = f"""
INSTRUCTIONS:
You are an expert penetration tester conducting privilege escalation on this target system that you have shell access to. 
Using the exploit finding tool linpeas.sh identify potential privilege escalation vectors, then attempt to exploit them step-by-step.
Based on the current context and command history, determine the next best command to execute to escalate privileges.
You have complete permission to test anything on the target system as part of this authorized penetration test.
You may search the web for privilege escalation techniques, vulnerabilities, and exploits.

Your response MUST be a JSON object with this exact format:
{{
    "reasoning": "Explanation of why this command is chosen",
    "command": "exact command to execute",
    "expected_outcome": "what you expect this command to reveal or accomplish",
    "continue_session": true/false
}}

DECISION CRITERIA:
1. If linPEAS hasn't been run, run linpeas.sh Assume its located in the current users home directory and run with: sh ~/linpeas.sh
2. If linPEAS has been run, analyze its output and attempt specific privilege escalation techniques, trying the highest likelihood and easiest to exploit findings first.
3. Attempt high likelyhood (RED/YELLOW) findings from linPEAS multiple times with different approaches before moving on to other techniques. 
4. If you've achieved root/admin privileges explain how and test that they work by listing the contents of the /root directory.
5. If you've exhausted reasonable options, set continue_session to false

IMPORTANT: All commands run must not be interactive, otherwise the ssh connection will hang while the command is running. 
Focus on practical, step-by-step privilege escalation. Always explain your reasoning.
"""
        return {"role": "system", "content": system_prompt}
    



    def make_user_prompt(self) -> Dict:
        """Build current context for LLM"""
        context = f"""
PENETRATION TEST SESSION CONTEXT
================================
SYSTEM INFORMATION:
{json.dumps(self.system_info, indent=2)}

COMMAND HISTORY:
"""
        for i, cmd_info in enumerate(self.command_history, 1):
            error_display = cmd_info['error'] if cmd_info['error'] else '[[NO ERROR]]'
            context += f"""
Command {i}: {cmd_info['command']}
Reasoning: {cmd_info['reasoning']}
Expected Outcome: {cmd_info['expected_outcome']}
Return Code: {cmd_info['return_code']}
Output: {cmd_info['output']}
Error: {error_display}
Timestamp: {cmd_info['timestamp']}
--------------------------------
"""

        if not self.command_history:
            context += "\n(No commands executed yet)"

        return {"role": "user", "content": context}
    


    def execute_command_with_approval(self, command_info: Dict) -> Optional[Dict]:
        """Execute command after getting user approval"""
        command = command_info['command']
        reasoning = command_info['reasoning']
        expected_outcome = command_info['expected_outcome']

        # Display command information
        print(f"\n{Fore.CYAN}{'='*60}")
        print(f"LLM COMMAND RECOMMENDATION #{self.iteration_count + 1}")
        print(f"{'='*60}{Style.RESET_ALL}")
        print(f"{Fore.YELLOW}Target:{Style.RESET_ALL} {self.target_ip}")
        print(f"{Fore.YELLOW}Current User:{Style.RESET_ALL} {self.current_user}")
        print(f"{Fore.YELLOW}Command:{Style.RESET_ALL} {command}")

        print(f"\n{Fore.GREEN}LLM Reasoning:{Style.RESET_ALL}")
        print(f"  {reasoning}")

        print(f"\n{Fore.GREEN}Expected Outcome:{Style.RESET_ALL}")
        print(f"  {expected_outcome}")

        # Get user approval
        print(f"\n{Fore.CYAN}{'='*60}{Style.RESET_ALL}")

        while True:
            try:
                response = input(f"{Fore.WHITE}Execute this command? (y/n/q): {Style.RESET_ALL}").lower().strip()

                if response == 'y':
                    break
                elif response == 'n':
                    print(f"{Fore.YELLOW}Command skipped by user{Style.RESET_ALL}")
                    return None
                elif response == 'q':
                    print(f"{Fore.RED}Session terminated by user{Style.RESET_ALL}")
                    return {'terminate': True}
                else:
                    print("Please enter 'y' (yes), 'n' (no), or 'q' (quit)")
                    continue
            except KeyboardInterrupt:
                print(f"\n{Fore.RED}Session interrupted by user{Style.RESET_ALL}")
                return {'terminate': True}

        # Execute the command
        print(f"{Fore.GREEN}Executing command...{Style.RESET_ALL}")

        try:
            start_time = time.time()
            result = self.ssh_client.execute_command(command, timeout=120)
            execution_time = time.time() - start_time

            # Log the command execution
            self.logger.info(f"Executed: {command} (return code: {result['return_code']}, time: {execution_time:.2f}s)")

            # Store in history
            command_record = {
                'command': command,
                'reasoning': reasoning,
                'expected_outcome': expected_outcome,
                'return_code': result['return_code'],
                'output': result['stdout'],
                'error': result['stderr'],
                'timestamp': datetime.now().isoformat()
            }

            self.command_history.append(command_record)

            # Display results
            print(f"\n{Fore.GREEN}Command completed in {execution_time:.2f}s{Style.RESET_ALL}")
            print(f"{Fore.YELLOW}Return Code:{Style.RESET_ALL} {result['return_code']}")

            if result['stdout']:
                print(f"\n{Fore.CYAN}Output:{Style.RESET_ALL}")
                # Truncate very long output for display
                output_display = result['stdout'][:2000]
                if len(result['stdout']) > 2000:
                    output_display += f"\n... (output truncated, {len(result['stdout'])} total characters)"
                print(output_display)

            if result['stderr']:
                print(f"\n{Fore.RED}Errors:{Style.RESET_ALL}")
                print(result['stderr'][:1000])

            return command_record

        except Exception as e:
            self.logger.error(f"Command execution failed: {e}")
            print(f"{Fore.RED}Command execution failed: {e}{Style.RESET_ALL}")
            return None

    def check_privilege_escalation(self) -> bool:
        """Check if privilege escalation was achieved"""
        
        output = self.ssh_client.execute_command('id').get('stdout', '').lower()
        
        if 'uid=0' in output:
            self.privilege_escalated = True
            return True

        return False
    

    def generate_session_summary(self):
        """Generate and display session summary"""
        print(f"\n{Fore.CYAN}{'='*80}")
        print(f"SESSION SUMMARY")
        print(f"{'='*80}{Style.RESET_ALL}")

        print(f"Target: {self.target_ip}")
        print(f"User: {self.username}")
        print(f"Session ID: {self.session_id}")
        print(f"Duration: {self.iteration_count} iterations")
        print(f"Commands Executed: {len([cmd for cmd in self.command_history if cmd.get('return_code') is not None])}")
        print(f"Privilege Escalated: {'YES' if self.privilege_escalated else 'NO'}")

        if self.privilege_escalated:
            print(f"\n{Fore.GREEN}üéâ SUCCESS: Privilege escalation achieved!{Style.RESET_ALL}")
        elif self.iteration_count >= self.max_iterations:
            print(f"\n{Fore.YELLOW}‚è±Ô∏è  Maximum iterations reached{Style.RESET_ALL}")
        else:
            print(f"\n{Fore.BLUE}‚ÑπÔ∏è  Session ended by user or LLM decision{Style.RESET_ALL}")

        # Save detailed report
        report_file = f"interactive_pentest_report_{self.session_id}.json"
        report_data = {
            'session_info': {
                'session_id': self.session_id,
                'target_ip': self.target_ip,
                'username': self.username,
                'start_user': self.current_user,
                'iterations': self.iteration_count,
                'privilege_escalated': self.privilege_escalated,
                'timestamp': datetime.now().isoformat()
            },
            'system_info': self.system_info,
            'command_history': self.command_history,
        }

        try:
            os.makedirs('reports', exist_ok=True)
            with open(f"reports/{report_file}", 'w') as f:
                json.dump(report_data, f, indent=2)

            print(f"\nüìÑ Detailed report saved: reports/{report_file}")

        except Exception as e:
            self.logger.error(f"Failed to save report: {e}")
